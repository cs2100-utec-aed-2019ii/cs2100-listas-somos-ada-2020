#ifndef FORWARDLIST
#define FORWARDLIST
#include "./ForwardListNode.h"
#include "./List.h"

template <typename T>
class ForwardList : public List<T>{
  protected:
  ForwardListNode<T> *tail;
  public:
  ForwardList(ForwardList &copia) : List<T>(copia)
  {

  }
  ForwardList(T* arreglo, int size) : List<T>(arreglo, size)
  {

  }
  ForwardList(Node<T>* copia) : List<T>(copia)
  {

  }
  ForwardList(int numero_elementos) : List<T>(numero_elementos)
  {

  } 
  ForwardList()
  {
    List<T>::head = NULL;
    tail = NULL;
  } 
  T front(void)
  {
    if(List<T>::head)
    {
      return List<T>::head->get_value();
    }
    return 0;
  }
  T back(void)
  {
    ForwardListNode<T> *temp = List<T>::head;
    if(temp)
    {
      while(temp->next)
      {
        temp = temp->next;
      }
      return temp->get_value();
    }
    return 0;
  }
  
  void push_back(const T& element)
  {
    if(List<T>::head)
    {
      ForwardListNode<T> *temp = List<T>::head;
      while(temp->next)
      {
        temp = temp->next;
      }
      temp->next = new Node<T>;
      temp->next->set_value(element);
      tail = temp->next;
      return;
    }
    List<T>::head = new Node<T>;
    List<T>::head->set_value(element);
    tail = List<T>::head;
  }
  void push_front(const T& element)
  {
    if(List<T>::head)
    {
        ForwardListNode<T> *temp = new ForwardListNode<T>;
        temp->set_value(element);
        ForwardListNode<T> *temp2 = List<T>::head;
        List<T>::head = temp;
        List<T>::head->next = temp2;
        return;
    }
    List<T>::head = new ForwardListNode<T>;
    List<T>::head->set_value(element);
  }

  ForwardListNode<T>* pop_back(void)
  {
    if(List<T>::head==NULL) {
      return NULL;
    }
    else if(List<T>::head->next==NULL){
      ForwardListNode<T> temp2 = *List<T>::head;
      delete List<T>::head;
      List<T>::head = NULL;
      tail = NULL;
      return &temp2;
    }
    ForwardListNode<T> *temp1 = List<T>::head;
    ForwardListNode<T> temp2;
    while (temp1->next->next) {
      temp1 = temp1->next;
    }
    temp2 = *temp1->next;
    delete temp1->next;
    temp1->next=NULL; 
    tail = temp1;
    return &temp2; 
  }
  ForwardListNode<T>* pop_front(void)
  {
    if(List<T>::head != NULL){
      ForwardListNode<T> temp;
      temp=*List<T>::head;
      ForwardListNode<T> *aux_borrar;
      aux_borrar=List<T>::head;
      
      List<T>::head=List<T>::head->next;
      delete aux_borrar;
      return &temp;
    }else{
      return NULL;
    }
  }

  T& operator[] (const int& posicion)
  {
    if(List<T>::head)
    {
      T temp2;
      ForwardListNode<T> *temp = List<T>::head;
      for(int i = 0; i < posicion; i++)
      {
        temp = temp->next;
      }
      temp2 = temp->get_value();
      return temp2;
    }
  }
  
  bool empty(void)
  {
    if(List<T>::head!=NULL){
      return true;
    }else{
      return false;
    }
  }
  unsigned int size(void)
  {
    unsigned int size=0;
    ForwardListNode<T> *temp=List<T>::head;
    while(temp!=NULL){
      size++;
      temp=temp->next;
    }
    return size;
  }
  void clear(void)
  {
    ForwardListNode<T> *aux=List<T>::head;
    while(List<T>::head!=NULL) {
      List<T>::head = List<T>::head->next;
      delete aux;
      aux=List<T>::head;
    }
    List<T>::head = NULL;
    tail = NULL;
  }

  void erase(Node<T>* element)
  {

  }
  void insert(Node<T>* element, const T& position)
  {

  }
  void drop(const T& item)
  {

  }

  List<T>& sort(void)
  {

  }
  List<T>& reverse(void)
  {

  }
};

#endif
